const express = require('express');
const fs = require('fs');
const path = require('path');
const app = express();
const PORT = process.env.PORT || 3000;
const DATA_PATH = path.join(__dirname, 'data.json');

app.use(express.json());
app.use(express.static(path.join(__dirname, 'public')));

// âœ… Login credentials
const USERS = {
  "student": "1234",
  "guest": "abcd",
  "admin": "5678",
  "library": "9999"
};

// ===== Helper Functions =====
function readSeats() {
  if (!fs.existsSync(DATA_PATH)) {
    return {
      seat1: { status: "vacant", user: null, break_until: null },
      seat2: { status: "vacant", user: null, break_until: null }
    };
  }
  return JSON.parse(fs.readFileSync(DATA_PATH, 'utf8'));
}

function writeSeats(data) {
  fs.writeFileSync(DATA_PATH, JSON.stringify(data, null, 2));
}

// ===== Login =====
app.post('/login', (req, res) => {
  const { seatId, username, password } = req.body;
  const seats = readSeats();

  if (!USERS[username] || USERS[username] !== password) {
    return res.json({ success: false, message: "Invalid credentials" });
  }

  // Prevent login if seat already occupied
  if (seats[seatId].status !== "vacant") {
    return res.json({ success: false, message: "Seat already occupied" });
  }

  // Successful login
  seats[seatId] = { status: "occupied", user: username, break_until: null };
  writeSeats(seats);
  console.log(`âœ… ${username} logged in at ${seatId}`);
  res.json({ success: true, message: "Login successful" });
});

// ===== Logout =====
app.post('/logout', (req, res) => {
  const { seatId } = req.body;
  const seats = readSeats();

  if (!seats[seatId]) return res.status(400).json({ success: false });

  seats[seatId] = { status: "vacant", user: null, break_until: null };
  writeSeats(seats);
  console.log(`ðŸ”´ ${seatId} logged out`);
  res.json({ success: true });
});

// ===== Break =====
app.post('/break', (req, res) => {
  const { seatId, minutes } = req.body;
  const seats = readSeats();

  if (!seats[seatId] || seats[seatId].status !== "occupied") {
    return res.json({ success: false, message: "Seat not occupied" });
  }

  const until = Date.now() + minutes * 60 * 1000;
  seats[seatId].status = "break";
  seats[seatId].break_until = until;
  writeSeats(seats);
  console.log(`â¸ï¸ ${seatId} on ${minutes} min break`);

  // Auto end break
  setTimeout(() => {
    const current = readSeats();
    const seat = current[seatId];
    if (seat && seat.status === "break" && Date.now() >= seat.break_until) {
      seat.status = "occupied";
      seat.break_until = null;
      writeSeats(current);
      console.log(`â–¶ï¸ ${seatId} break ended`);
    }
  }, minutes * 60 * 1000 + 2000);

  res.json({ success: true, message: "Break started" });
});

// ===== Update from ESP =====
app.post('/update-seat', (req, res) => {
  const { seatId, status } = req.body;
  const seats = readSeats();

  if (!seats[seatId]) {
    return res.status(400).json({ success: false, message: "Invalid seat ID" });
  }

  // Preserve user + break status
  const currentUser = seats[seatId].user;
  const currentBreak = seats[seatId].break_until;

  seats[seatId].status = status;

  // ðŸ§  Only clear user if ESP says vacant and no break
  if (status === "vacant" && !currentBreak) {
    seats[seatId].user = null;
    seats[seatId].break_until = null;
  } else {
    seats[seatId].user = currentUser;
    seats[seatId].break_until = currentBreak;
  }

  writeSeats(seats);
  res.json({ success: true });
});

// ===== Status endpoint =====
app.get('/status', (req, res) => {
  const seats = readSeats();
  res.json(seats);
});

// ===== Reset =====
app.post('/reset', (req, res) => {
  const blank = {
    seat1: { status: "vacant", user: null, break_until: null },
    seat2: { status: "vacant", user: null, break_until: null }
  };
  writeSeats(blank);
  res.json({ success: true });
});

// ===== Start server =====
app.listen(PORT, () => {
  console.log(`âœ… Server running on port ${PORT}`);
});














